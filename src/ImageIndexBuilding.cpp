////  ImageIndexBuilding.cpp//  ImageRetrievalEngine////  Created by XuRui on 15-3-22.//  Copyright (c) 2015Äê¨º XuRui. All rights reserved.//#include "ImageIndexBuilding.h"#include "ImageDescriptor.h"#include "ImagePreProcess.h"void ImageIndexBuilding::BuildingIndex(const std::string& LSH_file, const std::string& img_path,                                       const std::string& index_file){	ImagePreProcess img_preprocess;	ColorAutoCorrelogram img_match;	const int L = 25;	const int K = 5;	const double w = 4;    const int D = 360;    const std::string color_feature = "color_feature.yml";	cv::glob(img_path + "//*.jpg", image_dataset);	cv::FileStorage fs(index_file, cv::FileStorage::WRITE);    cv::FileStorage feature(color_feature, cv::FileStorage::WRITE);	LocalitySensitiveHashing LSH(L, K, w, D);    LSHFunction single_lsh;    single_lsh.a.assign(D, 0);    std::vector<LSHFunction> lsh_vec(K, single_lsh);    std::vector<std::vector<LSHFunction> > g_lshfunctions;    g_lshfunctions.assign(L, lsh_vec);    LSH.readLSHFunctions(LSH_file, g_lshfunctions);	for (int i = 0; i < image_dataset.size(); i++) {		candidate_img = cv::imread(image_dataset[i]);		const size_t last_slash_idx = image_dataset[i].find_last_of("\/");		if (std::string::npos != last_slash_idx)		{			image_dataset[i].erase(0, last_slash_idx + 1);		}		// Remove extension if present.		const size_t period_idx = image_dataset[i].rfind('.');		if (std::string::npos != period_idx)		{			image_dataset[i].erase(period_idx);		}		fs << "jpg" + image_dataset[i] << "[";        feature << "jpg" + image_dataset[i];		std::vector<double> correlogram(360, 0.0);		img_preprocess.ImgResizeProcess(candidate_img, resized_img);		cvtColor(resized_img, hsv_img, CV_BGR2HSV);		img_preprocess.HSVimgQuantization(hsv_img, qua_img);		img_match.CreateColorAutoCorrelogram(qua_img, correlogram);        feature << correlogram;		for (int l = 0; l < L; ++l) {			std::stringstream l_temp;			std::string l_num;			std::vector<int> lsh_vec(K, 0);			LSH.computeLSH(correlogram, l, w, g_lshfunctions, lsh_vec);			l_temp << l;			l_temp >> l_num;			fs << "{" << "g" + l_num << "[";			for (std::vector<int>::iterator iter = lsh_vec.begin(); iter < lsh_vec.end(); ++iter) {				fs << *iter;			}			fs << "]" << "}";		} 		fs << "]";		std::cout << "Building " << i << " index" << std::endl;	}	fs.release();}